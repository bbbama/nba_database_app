Bazy danych I – dokumentacja projektu
Dokumentacja projektu wykonywanego w ramach zajęć
BAZY DANYCH I

I. Projekt koncepcji, założenia

Tematem projektu jest aplikacja bazodanowa z przyjemnym dla użytkownika interfejsem graficznym, służąca  do zarządzania danymi dotyczącymi koszykarskiej ligi NBA. System obejmuje informacje o drużynach, zawodnikach, meczach oraz statystykach sportowych, odwzorowując rzeczywistą strukturę danych sportowych.

Celem projektu jest:
stworzenie spójnej i poprawnej logicznie bazy danych,
zaprezentowanie praktycznego wykorzystania relacyjnych baz danych,
umożliwienie użytkownikowi wygodnej obsługi danych poprzez GUI,
wykorzystanie mechanizmów PostgreSQL, takich jak klucze obce, widoki, funkcje agregujące, wyzwalacze oraz walidacja danych.

W projekcie przyjęto, że użytkownikiem systemu jest administrator danych ligi NBA np. analityk sportowy, który oczekuje intuicyjnego dostępu do danych oraz możliwości ich analizy.

Projektowana baza danych powinna spełniać następujące wymagania funkcjonalne:
przechowywanie danych o drużynach NBA (nazwa, miasto, trener, rok założenia),
przechowywanie danych o zawodnikach wraz z przypisaniem do drużyn,
rejestrowanie informacji o meczach (data, drużyna gospodarzy i gości, wynik),
zapisywanie statystyk zawodników w poszczególnych meczach,
obsługa dodatkowych elementów, takich jak areny (hale), sezony, tabele ligowe, kontrakty, kontuzje, trenerzy i nagrody zawodników,
możliwość dodawania, edytowania oraz przeglądania danych,
generowanie raportów i zestawień statystycznych,
zapewnienie spójności danych i eliminacja błędnych wpisów.

Baza danych realizuje następujące podstawowe funkcje:
zarządzanie relacjami pomiędzy tabelami (relacje 1-n oraz n-m),
automatyczna kontrola poprawności danych przy użyciu kluczy głównych i obcych,
walidacja danych za pomocą ograniczeń (CHECK), wyzwalaczy oraz reguł integralności,
obliczanie statystyk zbiorczych np. suma punktów zawodnika,
udostępnianie danych w formie widoków ułatwiających analizę i raportowanie,
wspieranie logiki biznesowej po stronie bazy danych.

II. Projekt diagramów (konceptualny)

Wejścia danych do systemu:
dane drużyn (nazwa, miasto, trener, rok założenia),
dane zawodników (imię, nazwisko, pozycja, drużyna),
dane meczów (data, drużyny, wyniki),
statystyki zawodników w meczach (punkty, asysty, zbiórki, minuty),
dane o kontuzjach zawodników,
dane o kontraktach zawodników,
dane o arenach sportowych,
dane o sezonach,
wyniki tabel ligowych,
dane o trenerach i sztabie,
informacje o przyznanych nagrodach.

Procesy systemu:
dodawanie i modyfikacja danych,
walidacja danych np. poprawność wyników,
obliczanie statystyk zbiorczych,
generowanie raportów i widoków.

Przechowywanie danych:
tabele relacyjne w bazie PostgreSQL: zespół, zawodnik, mecz, statystyki meczu, kontuzja, kontrakt, arena, sezon, tabela_ligowa, trener, nagroda.

Wyjścia danych z systemu:
zestawienia zawodników i drużyn,
wyniki meczów,
średnie statystyki zawodników,
raporty i widoki prezentowane w aplikacji GUI.

Encje:
Encja: Zespół
Reprezentuje drużynę NBA.
id_zespolu - klucz glowny,
nazwa,
miasto,
rok_zalozenia,
trener_glowny.

Encja: Zawodnik
Reprezentuje zawodnika NBA.
id_zawodnika - klucz główny,
imie,
nazwisko
pozycja,
data_urodzenia,
id_zespolu - klucz obcy.

Encja: Mecz
Reprezentuje rozegrany mecz NBA.
id_meczu - klucz główny,
data_meczu,
id_gospodarza - klucz obcy,
id_goscia - klucz obcy,
wynik_gospodarza,
wynik_goscia.

Encja: Statystyki_meczu
Encja asocjacyjna przechowująca statystyki zawodnika w konkretnym meczu.
id_statystyki - klucz główny,
id_meczu - klucz obcy,
id_zawodnika - klucz obcy,
minuty,
punkty,
asysty,
zbiorki.

Encja: Kontuzja
Reprezentuje kontuzje odniesiona przez zawodnika.
id_kontuzji - klucz główny,
id_zawodnika - klucz obcy,
typ_kontuzji,
data_rozpoczecia,
data_zakonczenia,
status.

Encja: Kontrakt
Reprezentuje kontrakt zawarty miedzy zawodnikiem a zespolem.
id_kontraktu - klucz główny,
id_zawodnika - klucz obcy,
id_zespolu - klucz obcy,
data_poczatek,
data_koniec,
wynagrodzenie_roczne.

Encja: Arena
Reprezentuje arene sportowa, na ktorej odbywaja sie mecze.
id_arena - klucz główny,
nazwa,
miasto,
pojemnosc,
rok_otwarcia.

Encja: Sezon
Reprezentuje sezon rozgrywek NBA.
id_sezonu - klucz główny,
rok_rozpoczecia,
rok_zakonczenia.

Encja: Tabela_ligowa
Reprezentuje pozycje zespolu w tabeli ligowej w danym sezonie.
id_tabeli - klucz główny,
id_sezonu - klucz obcy,
id_zespolu - klucz obcy,
liczba_zwyciestw,
liczba_porazek,
miejsce_w_tabeli.

Encja: Trener
Reprezentuje trenera lub czlonka sztabu trenerskiego.
id_trenera - klucz główny,
imie,
nazwisko,
rola,
id_zespolu - klucz obcy.

Encja: Nagroda
Reprezentuje nagrode przyznana zawodnikowi.
id_nagrody - klucz główny,
id_zawodnika - klucz obcy,
nazwa_nagrody,
rok.

W systemie zaprojektowano następujące relacje:
Relacja: Zespół - Gracz (1:N)
Jeden zespół może mieć wielu graczy.
Gracz może należeć do jednego zespołu (lub tymczasowo do żadnego).
Relacja realizowana przez klucz obcy id_zespolu w tabeli zawodnik.

Relacja: Zespół - Mecz (1:N)
Zespół może brać udział w wielu meczach jako gospodarz lub gość.
Każdy mecz ma dokładnie dwóch uczestników (gospodarza i gościa).
Relacja realizowana przez klucze obce id_gospodarza i id_goscia w tabeli mecz.

Relacja: Gracz -  Mecz (N:M)
Gracz może brać udział w wielu meczach.
Mecz obejmuje wielu graczy.
Relacja wiele-do-wielu została wyeliminowana poprzez wprowadzenie tabeli pośredniej statystyki_meczu.
Tabela asocjacyjna:
przechowuje statystyki gracza w danym meczu,
posiada unikalne połączenie id_meczu + id_zawodnika,
stanowi końcowy element logiki bazy danych.

Relacja: Zawodnik - Kontuzja (1:N)
Jeden zawodnik może mieć wiele kontuzji w swojej karierze.
Każdy wpis o kontuzji odnosi się do jednego zawodnika.
Relacja realizowana przez klucz obcy id_zawodnika w tabeli kontuzja.

Relacja: Zawodnik - Zespół (N:M przez Kontrakt)
Zawodnik może mieć w swojej karierze kontrakty z wieloma zespołami.
Zespół podpisuje kontrakty z wieloma zawodnikami.
Relacja jest realizowana przez tabelę asocjacyjną kontrakt, która przechowuje szczegóły umowy (okres, wynagrodzenie).

Relacja: Zespół - Arena (N:1)
Wiele zespołów może rozgrywać mecze na tej samej arenie (chociaż zazwyczaj jeden zespół ma jedną główną arenę).
Każdy zespół ma przypisaną jedną, główną arenę.
Relacja realizowana przez klucz obcy id_arena w tabeli zespol.

Relacja: Sezon - Mecz (1:N)
Jeden sezon składa się z wielu meczy.
Każdy mecz jest przypisany do konkretnego sezonu.
Relacja realizowana przez klucz obcy id_sezonu w tabeli mecz.

Relacja: Sezon/Zespół - Tabela ligowa (1:1 dla pary)
Tabela ligowa przechowuje pozycję jednego zespołu w jednym, konkretnym sezonie.
Występuje unikalne powiązanie (id_sezonu, id_zespolu).

Relacja: Zespół - Trener (1:N)
Jeden zespół zatrudnia wielu członków sztabu trenerskiego (główny, asystenci).
Każdy trener jest przypisany do jednego zespołu.
Relacja realizowana przez klucz obcy id_zespolu w tabeli trener.

Relacja: Zawodnik - Nagroda (1:N)
Jeden zawodnik może zdobyć wiele nagród w trakcie swojej kariery.
Każda nagroda jest przypisana do konkretnego zawodnika.
Relacja realizowana przez klucz obcy id_zawodnika w tabeli nagroda.

Diagram ERD:


III. Projekt logiczny

9. Analiza zależności funkcyjnych i normalizacja tabel (3NF i BCNF)

W tej części sprawdzamy, czy tabele w naszej bazie danych spełniają warunki **Trzeciej Postaci Normalnej (3NF)** oraz **Postaci Normalnej Boyce’a-Codda (BCNF)**. Zapewnienie zgodności z tymi postaciami jest kluczowe dla stworzenia solidnej i dobrze zaprojektowanej bazy danych, która unika problemów z niespójnością danych.

*   **3NF (Trzecia postać normalna):** W uproszczeniu, tabela jest w 3NF, jeśli jej wszystkie atrybuty zależą *tylko* od klucza głównego, a nie od innych atrybutów niebędących kluczem. Zapobiega to sytuacji, w której zmiana jednej danej pociąga za sobą konieczność zmiany innych danych w tej samej tabeli.

*   **BCNF (Postać normalna Boyce'a-Codda):** To jest nieco bardziej rygorystyczna wersja 3NF. Mówi, że każdy atrybut lub grupa atrybutów, która determinuje (jednoznacznie określa) jakiekolwiek inne atrybuty, musi być superkluczem (czyli zawierać w sobie klucz kandydujący).

**Analiza tabel w projekcie:**

**1. Tabele z prostym kluczem głównym (np. `zawodnik`, `mecz`, `arena`, `zespol` itd.)**

Większość naszych tabel, jak `zawodnik` czy `arena`, ma pojedynczy, prosty klucz główny (np. `id_zawodnika`).
*   W tych tabelach wszystkie pozostałe kolumny (np. `imie`, `pozycja`) opisują bezpośrednio byt określony przez klucz główny. Nie ma żadnych zależności przechodnich (atrybut niekluczowy nie zależy od innego atrybutu niekluczowego), więc **warunek 3NF jest spełniony**.
*   Jedynym determinantem (atrybutem, od którego zależą inne) jest sam klucz główny. Ponieważ klucz główny jest z definicji superkluczem, **warunek BCNF jest również spełniony**.

**2. Tabele asocjacyjne (`statystyki_meczu` i `tabela_ligowa`)**

Te tabele mają, oprócz własnego klucza głównego (np. `id_statystyki`), także złożony klucz kandydujący (np. `(id_meczu, id_zawodnika)`), który zapewnia unikalność wpisów.
*   Atrybuty takie jak `punkty` czy `minuty` zależą od całego złożonego klucza kandydującego, a nie od żadnego atrybutu niekluczowego. Dlatego **warunek 3NF jest spełniony**.
*   W tych tabelach mamy dwa determinanty: klucz główny (`id_statystyki`) oraz klucz kandydujący (`(id_meczu, id_zawodnika)`). Oba są superkluczami. Oznacza to, że **warunek BCNF jest także spełniony**.

**Podsumowanie**

Wszystkie tabele w naszym projekcie zostały zaprojektowane zgodnie z wymaganiami **Postaci Normalnej Boyce'a-Codda (BCNF)**. Dzięki temu schemat bazy danych jest poprawny, spójny i odporny na anomalie związane z manipulacją danymi.


8. Słowniki danych

Poniżej przedstawiono słownik danych dla każdej tabeli w bazie, zawierający opis kolumn, ich typy danych oraz istotne uwagi i ograniczenia.

**1. Tabela: `zespol`**
*   `id_zespolu` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator zespołu.
*   `nazwa` (VARCHAR(100)): Nazwa zespołu, unikalna dla każdego zespołu.
*   `miasto` (VARCHAR(100)): Miasto, z którego pochodzi zespół.
*   `rok_zalozenia` (SMALLINT): Rok założenia zespołu (wartość > 1850 i <= bieżący rok).
*   `trener_glowny` (VARCHAR(100)): Imię i nazwisko głównego trenera zespołu.
*   `id_arena` (INTEGER): Klucz obcy, identyfikator głównej areny zespołu (może być NULL).

**2. Tabela: `zawodnik`**
*   `id_zawodnika` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator zawodnika.
*   `imie` (VARCHAR(50)): Imię zawodnika.
*   `nazwisko` (VARCHAR(50)): Nazwisko zawodnika.
*   `pozycja` (VARCHAR(30)): Pozycja, na której gra zawodnik (np. 'Rozgrywający', 'Skrzydłowy', 'Środkowy').
*   `data_urodzenia` (DATE): Data urodzenia zawodnika.
*   `id_zespolu` (INTEGER): Klucz obcy, identyfikator zespołu, do którego należy zawodnik (może być NULL, jeśli zawodnik jest bez drużyny).

**3. Tabela: `mecz`**
*   `id_meczu` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator meczu.
*   `data_meczu` (DATE): Data rozegrania meczu.
*   `id_gospodarza` (INTEGER): Klucz obcy, identyfikator zespołu gospodarzy.
*   `id_goscia` (INTEGER): Klucz obcy, identyfikator zespołu gości.
*   `wynik_gospodarza` (SMALLINT): Wynik punktowy zespołu gospodarzy (wartość >= 0).
*   `wynik_goscia` (SMALLINT): Wynik punktowy zespołu gości (wartość >= 0).
*   `id_sezonu` (INTEGER): Klucz obcy, identyfikator sezonu, w którym rozegrano mecz (może być NULL).
*   `CONSTRAINT roznorodne_druzyny`: Zapewnia, że id_gospodarza różni się od id_goscia.

**4. Tabela: `statystyki_meczu`**
*   `id_statystyki` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator statystyki meczu.
*   `id_meczu` (INTEGER): Klucz obcy, identyfikator meczu, którego dotyczą statystyki.
*   `id_zawodnika` (INTEGER): Klucz obcy, identyfikator zawodnika, którego dotyczą statystyki.
*   `minuty` (SMALLINT): Liczba minut rozegranych przez zawodnika w meczu (wartość >= 0).
*   `punkty` (SMALLINT): Liczba punktów zdobytych przez zawodnika w meczu (wartość >= 0).
*   `asysty` (SMALLINT): Liczba asyst wykonanych przez zawodnika w meczu (wartość >= 0).
*   `zbiorki` (SMALLINT): Liczba zbiórek (reboundów) zaliczonych przez zawodnika w meczu (wartość >= 0).
*   `UNIQUE (id_meczu, id_zawodnika)`: Zapewnia unikalność statystyk dla danego zawodnika w danym meczu.

**5. Tabela: `kontuzja`**
*   `id_kontuzji` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator kontuzji.
*   `id_zawodnika` (INTEGER): Klucz obcy, identyfikator zawodnika, który doznał kontuzji.
*   `typ_kontuzji` (VARCHAR(100)): Opis typu kontuzji (np. 'skręcenie kostki', 'zerwanie więzadła').
*   `data_rozpoczecia` (DATE): Data rozpoczęcia kontuzji.
*   `data_zakonczenia` (DATE): Data zakończenia kontuzji.
*   `status` (VARCHAR(20)): Status kontuzji ('aktywna', 'wyleczona', 'nieznany').

**6. Tabela: `kontrakt`**
*   `id_kontraktu` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator kontraktu.
*   `id_zawodnika` (INTEGER): Klucz obcy, identyfikator zawodnika związanego kontraktem.
*   `id_zespolu` (INTEGER): Klucz obcy, identyfikator zespołu, z którym zawarto kontrakt.
*   `data_poczatek` (DATE): Data rozpoczęcia kontraktu.
*   `data_koniec` (DATE): Data zakończenia kontraktu.
*   `wynagrodzenie_roczne` (NUMERIC(12,2)): Roczne wynagrodzenie zawodnika w ramach kontraktu (wartość >= 0).

**7. Tabela: `arena`**
*   `id_arena` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator areny.
*   `nazwa` (VARCHAR(100)): Nazwa areny.
*   `miasto` (VARCHAR(100)): Miasto, w którym znajduje się arena.
*   `pojemnosc` (INTEGER): Całkowita pojemność areny (liczba miejsc, wartość > 0).
*   `rok_otwarcia` (SMALLINT): Rok otwarcia areny (wartość > 1850 i <= bieżący rok).

**8. Tabela: `sezon`**
*   `id_sezonu` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator sezonu.
*   `rok_rozpoczecia` (SMALLINT): Rok rozpoczęcia sezonu (wartość > 1900 i <= bieżący rok).
*   `rok_zakonczenia` (SMALLINT): Rok zakończenia sezonu (wartość >= rok_rozpoczecia i <= bieżący rok).

**9. Tabela: `tabela_ligowa`**
*   `id_tabeli` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator wpisu w tabeli ligowej.
*   `id_sezonu` (INTEGER): Klucz obcy, identyfikator sezonu, którego dotyczy wpis.
*   `id_zespolu` (INTEGER): Klucz obcy, identyfikator zespołu, którego dotyczy wpis.
*   `liczba_zwyciestw` (SMALLINT): Liczba zwycięstw zespołu w danym sezonie (wartość >= 0).
*   `liczba_porazek` (SMALLINT): Liczba porażek zespołu w danym sezonie (wartość >= 0).
*   `miejsce_w_tabeli` (SMALLINT): Miejsce zajęte przez zespół w tabeli ligowej w danym sezonie (wartość > 0).
*   `UNIQUE(id_sezonu, id_zespolu)`: Zapewnia unikalność pozycji zespołu w tabeli dla danego sezonu.

**10. Tabela: `trener`**
*   `id_trenera` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator trenera.
*   `imie` (VARCHAR(50)): Imię trenera.
*   `nazwisko` (VARCHAR(50)): Nazwisko trenera.
*   `rola` (VARCHAR(50)): Rola trenera w zespole ('glowny', 'asystent', 'przygotowanie fizyczne').
*   `id_zespolu` (INTEGER): Klucz obcy, identyfikator zespołu, w którym trener pracuje (może być NULL).

**11. Tabela: `nagroda`**
*   `id_nagrody` (SERIAL / INTEGER): Klucz główny tabeli, unikalny identyfikator nagrody.
*   `id_zawodnika` (INTEGER): Klucz obcy, identyfikator zawodnika, który otrzymał nagrodę.
*   `nazwa_nagrody` (VARCHAR(100)): Nazwa otrzymanej nagrody.
*   `rok` (SMALLINT): Rok przyznania nagrody (wartość > 1900 i <= bieżący rok).  
**Opis:** Widok łączy dane z tabel `mecz` i `zespol`, aby pokazać datę meczu, nazwy zespołów gospodarzy i gości oraz ich wyniki.

**11.2. Przykładowe operacje DML (INSERT, UPDATE, DELETE)**

**Operacja: Dodanie nowego zawodnika (`INSERT`)
*   **Cel:** Umożliwia dodanie nowego zawodnika do bazy danych.
*   **SQL:**
    ```sql
    INSERT INTO zawodnik (imie, nazwisko, pozycja, data_urodzenia, id_zespolu)
    VALUES ('Michael', 'Jordan', 'Rzucający obrońca', '1963-02-17', 1); -- Zakładając, że ID 1 to Chicago Bulls
    ```
*   **Opis:** Zapytanie wstawia nowy wiersz do tabeli `zawodnik` z podanymi danymi. `id_zawodnika` zostanie wygenerowane automatycznie dzięki typowi `SERIAL`.

**Operacja: Zmiana zespołu zawodnika (`UPDATE`)
*   **Cel:** Umożliwia przypisanie zawodnika do innego zespołu.
*   **SQL:**
    ```sql
    UPDATE zawodnik
    SET id_zespolu = 2 -- Zakładając, że ID 2 to Los Angeles Lakers
    WHERE id_zawodnika = 10; -- Zakładając, że aktualizujemy zawodnika o ID 10
    ```
*   **Opis:** Zapytanie aktualizuje kolumnę `id_zespolu` dla zawodnika o określonym `id_zawodnika`, co w praktyce oznacza jego transfer do innej drużyny.

**Operacja: Usunięcie zawodnika (`DELETE`)
*   **Cel:** Umożliwia usunięcie zawodnika z bazy danych.
*   **SQL:**
    ```sql
    DELETE FROM zawodnik
    WHERE id_zawodnika = 15; -- Zakładając, że usuwamy zawodnika o ID 15
    ```
*   **Opis:** Zapytanie usuwa wiersz odpowiadający zawodnikowi o podanym `id_zawodnika`. Dzięki kaskadowemu usuwaniu (`ON DELETE CASCADE`) w innych tabelach (np. `statystyki_meczu`, `kontrakt`), wszystkie powiązane z nim wpisy również zostaną automatycznie usunięte.

**11.3. Przykładowe zapytania agregujące i raportowe**

**Zapytanie: Bilans zwycięstw i porażek zespołu w danym sezonie**
*   **Cel:** Prezentuje bilans zwycięstw i porażek dla każdego zespołu w wybranym sezonie.
*   **SQL:**
    ```sql
    SELECT
        z.nazwa AS nazwa_zespolu,
        tl.liczba_zwyciestw,
        tl.liczba_porazek,
        tl.miejsce_w_tabeli
    FROM tabela_ligowa tl
    JOIN zespol z ON tl.id_zespolu = z.id_zespolu
    WHERE tl.id_sezonu = 1 -- Przykładowy ID sezonu
    ORDER BY tl.miejsce_w_tabeli ASC;
    ```
*   **Opis:** Zapytanie łączy tabelę `tabela_ligowa` z tabelą `zespol`, aby wyświetlić nazwę zespołu oraz jego bilans zwycięstw, porażek i miejsce w tabeli dla określonego sezonu.

**Zapytanie: Zawodnik z największą liczbą punktów w pojedynczym meczu**
*   **Cel:** Identyfikuje zawodnika, który zdobył najwięcej punktów w jednym meczu, wraz z informacjami o tym meczu.
*   **SQL:**
    ```sql
    SELECT
        s.punkty,
        z.imie,
        z.nazwisko,
        m.data_meczu,
        zes.nazwa AS zespol_zawodnika
    FROM statystyki_meczu s
    JOIN zawodnik z ON s.id_zawodnika = z.id_zawodnika
    JOIN mecz m ON s.id_meczu = m.id_meczu
    JOIN zespol zes ON z.id_zespolu = zes.id_zespolu
    ORDER BY s.punkty DESC
    LIMIT 1;
    ```
*   **Opis:** Zapytanie łączy dane ze `statystyki_meczu`, `zawodnik`, `mecz` i `zespol` w celu znalezienia maksymalnej liczby punktów zdobytych w jednym meczu przez zawodnika i wyświetla szczegóły tego osiągnięcia.




